#!/usr/bin/env python
# encoding: utf-8

from __future__ import print_function, division
import subprocess
import os
import tempfile
import sys
import re
import os
import glob
import math


class CommandError(Exception):
    """There was an error in calling the command."""
    
    def __init__(self, function=None, error=None, *hints):
        if function is None:
            function = "unknown function"
        if error is None:
            error = "unspecified"
        msg = "Error '%s' occured in %s" % (error, function)
        super(CommandError, self).__init__(msg)
        self.function = function
        self.error    = error
        self.hints    = hints
        self.report   = (error,) + hints


class CommandFailed(Exception):
    """A command has failed to carry out fully."""

    def __init__(self, function=None, error=None, *hints):
        if function is None:
            function = "unknown function"
        if error is None:
            error = "unspecified"
        msg = "Error '%s' occured in %s" % (error, function)
        super(CommandFailed, self).__init__(msg)
        self.function = function
        self.error    = error
        self.hints    = hints
        self.report   = (error,) + hints


def schedule(command=None, script=None, settings=None, replace=None, workdir=None, environment=None, output=None):
    '''
    schedule [command=<command string>] [script=<path to script>] \\
             settings=<settings string> \\
             [replace=<"key:value|key:value" string>] \\
             [workdir=<path to working directory>] \\
             [environment=<path to environment setup script>] \\
             [output=<string specifying how to process output>]

    USE
    ===

    Schedules the provided command the referenced script to be run by the
    specified scheduler (PBS, LSF, SLURM are currently supported).

    PARAMETERS
    ==========

    Required parameters
    -------------------

    To run successfully, both one of the following has to be provided:

    --command   The string to be executed. It can be a single command or a
                complex multiline script.
    --script    The path to a script to be executed.

    as well the settings need to be specified by:

    --settings  A string specifying the scheduler to be used and the additional
                settings for it.

    Settings string should be a comma separated list of parameters. The first
    parameter has to be the scheduler name (PBS, LSF, SLURM), the rest of the
    parameters are key-value pairs that are to be passed as settings to the
    scheduler. Additional parameters common to all the schedulers can be
    specified:

    * jobname  - the name of the job to run
    * comname  - the name of the command the job runs
    * jobnum   - the number of the job being run

    Example settings strings:

    "SLURM,jobname=bet1,time=03-24:00:00,ntasks=10,cpus-per-task=2,mem-per-cpu=2500,partition=pi_anticevic"
    "LSF,jobname=DWIproc,jobnum=1,cores=20,mem=250000,walltime=650:00,queue=anticevic"

    Optional parameters
    -------------------

    --replace       A string of key-value pairs that specify the specific values
                    to be imputed into the script or command.
    --workdir       A path to the working directory in which the command or
                    script is to be executed.
    --environment   A path to a script to be executed before all other commands
                    to set up the environment for execution.
    --output        A string specifying whether to return or redirect the
                    standard output and error. See "REDIRECTING OUTPUT" for
                    details

    If the optional parameters are not specified, they will not be used.

    VALUE EMBEDDING
    ===============

    If replace parameter is set, all instances of {{key}} in the command or
    script will be replaced with the provided value. The key/value pairs need
    to be separated by pipe characted, whereas key and value need to be
    separated by a colon. An example replacement string:

    "subject:AP23791|folder:/studies/WM/Subjects/AP23791"

    REDIRECTING OUTPUT
    ==================

    If no output is specified, the job's standard output and error (stdout,
    stderr) are left as is and processed by the scheduler, and the result of
    submitting the job is printed to standard output. Output string can specify
    four different directives provided by "<key>:<value>" strings separated by
    pipe:

    * stdout - specifies a path to a log file that should store standard output
               of the submitted job
    * stderr - specified a path to a log file that should store error output
               of the submitted job
    * both   - specifies a path to a log file that should store joint standard
               and error outputs of the submitted job
    * return - specifies whether standard output ('stdout'), error outpout
               ('stderr'), both ('both') or none ('none') should be returned as
               a string from the job submission call.

    Specify "return" value only when schedule is used as a function called from
    another python script or function to process the result.

    Examples:

    * "stdout:processing.log"
    * "stdout:processing.output.log|stderr:processing.error.log"
    * "both:processing.log|return:true"

    Do not specify error and standard outputs both using --output parameter and
    scheduler specific options within settings string.

    SCHEDULER SPECIFICS
    ===================

    Each of the supported scheduler systems has a somewhat different way of
    specifying job parameters. Please see documentation for each of the
    supported schedulers to provide the correct settings. Below are the
    information for each of the schedulers on how to specify --settings.

    PBS settings
    ------------

    PBS uses various flags to specify parameters. Be careful that the settings
    string includes only comma separated 'key=value' pairs. Scheduler will then
    do its best to use the right flags. Specifically:

    Keys: mem, walltime, software, file, procs, pmem, feature, host,
    naccesspolicy, epilogue, prologue will be submitted using:
    "#PBS -l <key>=<value>".

    Keys: j, m, o, S, a, A, M, q, t, e will be submitted using:
    "#PBS -<key> <value>"

    Key: depend will be submitted using:

    "#PBS -W depend=<value>"

    Key: nodes is a special case. It can have up to three values separated by
    colon (":"). If there is only one value e.g. "nodes=4" it will submit:

    "#PBS -l nodes=4"

    When there are two values e.g. "nodes=4:2" it will submit:

    "#PBS -l nodes=4:ppn=2"

    When there are three values what is submitted depends on the type of the
    last value. When it is numeric, e.g. "nodes:8:4:2", it will submit:

    "#PBS -l nodes=8:ppn=4:cpus=2"

    If the last of the three values is a string, e.g. "nodes:8:4:blue", it will
    submit the last value as a self-standing key:

    "#PBS -l nodes=8:ppn=4:blue"

    LSF settings
    ------------

    For LSF the following key/value parameters are parsed as:

    * queue    -> "#BSUB -q <queue>"
    * mem      -> "#BSUB -R 'span[hosts=1] rusage[mem=<mem>]"
    * walltime -> "#BSUB -W <walltime>"
    * cores    -> "#BSUB -n <cores>"

    Keys: g, G, i, L, cwd, outdir, p, s, S, sla, sp, T, U, u, v, e, eo, o, oo
    will be submitted using:

    "#BSUB -<key> <value>"

    SLURM settings
    --------------

    For SLURM any provided key/value pair will be passed in the form:

    "#SBATCH --<key>=<value>"

    Some of the possible parameters to set are:

    partition        ... The partition (queue) to use
    nodes            ... Total number of nodes to run on
    ntasks           ... Number of tasks
    cpus-per-task    ... Number of cores per task
    time             ... Maximum wall time DD-HH:MM:SS
    constraint       ... Specific node architecture
    mem-per-cpu      ... Memory requested per CPU in MB
    mail-user        ... Email address to send notifications to
    mail-type        ... On what events to send emails


    EXAMPLE USE
    ===========

    gmri schedule command="bet t1.nii.gz brain.nii.gz" \\
                  settings="SLURM,jobname=bet1,time=03-24:00:00,ntasks=10,cpus-per-task=2,mem-per-cpu=2500,partition=pi_anticevic"

    gmri schedule command="bet {{in}} {{out}}" \\
                  replace="in:t1.nii.gz|out:brain.nii.gz" \\
                  settings="SLURM,jobname=bet1,time=03-24:00:00,ntasks=10,cpus-per-task=2,mem-per-cpu=2500,partition=pi_anticevic" \\
                  workdir="/studies/WM/Subjects/AP23791/images/structural"

    ----------------
    Written by Grega RepovÅ¡, 2017-06-17

    Changelog
    2017-09-30 - Grega Repovs
                 Added additional options to scheduling LSF jobs.
    2017-09-30 - Grega Repovs
                 Added options to redirect job output to log files.
    2018-10-03 - Grega Repovs
                 Added checking for validity of log file directories.
    2018-10-04 - Grega Repovs
                 Excluded log validity checking for 'return'.
    2019-03-07 - Jure Demsar
                 Python3 support.
    '''

    # --- check inputs

    if command is None and script is None:
        raise CommandError("schedule", "Missing parameter", "Either command or script need to be specified to run scheduler!")

    if command is not None and script is not None:
        raise CommandError("schedule", "Parameter conflict", "Only command or script need to be provided to run scheduler!")

    if settings is None:
        raise CommandError("schedule", "Missing parameter", "Settings need to be provided to run scheduler!")

    # --- parse settings

    try:
        setList   = [e.strip() for e in settings.split(",")]
        scheduler = setList.pop(0)
        setDict   = dict([e.strip().split("=") for e in setList])
        jobname   = setDict.pop('jobname', "schedule")
        comname   = setDict.pop('comname', "")
        jobnum    = setDict.pop('jobnum', "1")
    except:
        raise CommandError("schedule", "Misspecified parameter", "Could not parse the settings string:", settings)

    if scheduler not in ['PBS', 'LSF', 'SLURM']:
        raise CommandError("schedule", "Misspecified parameter", "First value in the settings string has to specify one of PBS, LSF, SLURM!", "The settings string submitted was:", settings)

    # --- compile command to pass

    if command is None:
        if not os.path.exists(script):
            raise CommandFailed("schedule", "File not found", "The specified script does not exist! [%s]" % (script))
        command = open(script, "r")

    if workdir is not None:
        if not os.path.exists(workdir):
            raise CommandFailed("schedule", "Folder does not exist", "The specified working directory does not exist! [%s]" % (workdir))
        command = "cd %s\n" % (workdir) + command

    if environment is not None:
        if not os.path.exists(environment):
            raise CommandFailed("schedule", "File not found", "The specified environment script does not exist! [%s]" % (environment))
        command = open(environment, "r") + "\n" + command

    # --- do search replace

    if replace is not None:
        replace = [e.strip().split(":") for e in replace.split("|")]

        for key, value in replace:
            command.replace("{{%s}}" % (key), value)


    # --- parse output

    outputs = {'stdout': None, 'stderr': None, 'both': None, 'return': None}

    if output is not None:
        for k, v in [[f.strip() for f in e.split(":")] for e in output.split("|")]:
            if not os.path.exists(os.path.dirname(v)) and k != 'return':
                raise CommandFailed("schedule", "Folder does not exist", "The specified folder for the '%s' log file does not exist! [%s]" % (k, os.path.dirname(v)), "Please check your paths!")
            outputs[k] = v

    if outputs['both'] is not None:
        outputs['stderr'] = outputs['both']
        outputs['stdout'] = outputs['both']

    # --- build scheduler commands

    sCommand = ""

    if scheduler == "PBS":
        for k, v in setDict.items():
            if k in ('mem', 'walltime', 'software', 'file', 'procs', 'pmem', 'feature', 'host', 'naccesspolicy', 'epilogue', 'prologue'):
                sCommand += "#PBS -l %s=%s\n" % (k, v)
            elif k in ('j', 'm', 'o', 'S', 'a', 'A', 'M', 'q', 't', 'e'):
                sCommand += "#PBS -%s %s\n" % (k, v)
            elif k == 'depend':
                sCommand += "#PBS -W depend=%s\n" % (v)
            elif k == 'nodes':
                v = v.split(':')
                res = 'nodes=%s' % (v.pop(0))
                if v:
                    res += ":ppn=%s" % (v.pop(0))
                if v:
                    if v[0].isnumeric():
                        res += ":gpus=%s" % (v.pop(0))
                    else:
                        res += ":" + v.pop(0)
        sCommand += "#PBS -N %s-%s#%s\n" % (jobname, comname, jobnum)
        if outputs['stdout'] is not None:
            sCommand += "#PBS -o %s\n" % (outputs['stdout'])
        if outputs['stderr'] is not None:
            sCommand += "#PBS -e %s\n" % (outputs['stderr'])
        if outputs['both']:
            sCommand += "#PBS -j oe\n"
        com = 'qsub'

    elif scheduler == "LSF":
        sCommand += "#BSUB -o %s-%s_#%s_%%J\n" % (jobname, comname, jobnum)
        for k, v in [('queue', '#BSUB -q %s\n'), ('mem', "#BSUB -R 'span[hosts=1] rusage[mem=%s]'\n"), ('walltime', '#BSUB -W %s\n'), ('cores', '#BSUB -n %s\n')]:
            if k in setDict:
                sCommand += v % (setDict[k])
        for k, v in setDict.items():
            if k in ('g', 'G', 'i', 'L', 'cwd', 'outdir', 'p', 's', 'S', 'sla', 'sp', 'T', 'U', 'u', 'v', 'e', 'eo', 'o', 'oo'):
                sCommand += "#BSUB -%s %s\n" % (k, v)
        sCommand += "#BSUB -P %s-%s\n" % (jobname, comname)
        sCommand += "#BSUB -J %s-%s#%d\n" % (jobname, comname, jobnum)
        if outputs['stdout'] is not None:
            sCommand += "#BSUB -o %s\n" % (outputs['stdout'])
        if outputs['stderr'] is not None:
            sCommand += "#BSUB -e %s\n" % (outputs['stderr'])
        com = 'bsub'

    elif scheduler == "SLURM":
        sCommand += "#!/bin/sh\n"
        sCommand += "#SBATCH --job-name=%s-%s#%s\n" % (jobname, comname, jobnum)
        for key, value in setDict.items():
            sCommand += "#SBATCH --%s=%s\n" % (key.replace('--', ''), value)
        if outputs['stdout'] is not None:
            sCommand += "#SBATCH -o %s\n" % (outputs['stdout'])
        if outputs['stderr'] is not None:
            sCommand += "#SBATCH -e %s\n" % (outputs['stderr'])
        com = 'sbatch'

    # --- run scheduler

    print("Submitting:\n------------------------------\n", sCommand + command)

    if outputs['return'] is None:
        serr = None
        sout = None
    elif outputs['return'] == 'both':
        serr = subprocess.STDOUT
        sout = subprocess.PIPE
    elif outputs['return'] == 'stderr':
        serr = subprocess.PIPE
        sout = None
    elif outputs['return'] == 'stdout':
        serr = None
        sout = subprocess.PIPE

    run = subprocess.Popen(com, shell=True, stdin=subprocess.PIPE, stdout=sout, stderr=serr, close_fds=True)
    run.stdin.write(sCommand + command)
    run.stdin.close()

    # ---- returning results

    if outputs['return'] in ['both', 'stdout']:
        result = run.stdout.read()
        return result
    elif outputs['return'] in ['stderr']:
        result = run.stderr.read()
        return result


def getSubjidFromBatchFile(filename):
    '''
    getSubjidFromBatchFile(filename)

    An internal function for reading batch.txt files. It reads the file and
    returns a list of subjects with the information on images and the additional
    parameters specified in the header.

    ---
    Written by Grega Repovs and Jure Demsar.
    '''

    if not os.path.exists(filename):
        print("\n\n=====================================================\nERROR: Batch file does not exist [%s]", file=filename)
        raise ValueError("ERROR: Batch file not found: %s" % (filename))

    s = open(filename, "r").read()
    s = s.replace("\r", "\n")
    s = s.replace("\n\n", "\n")
    s = re.sub("^#.*?\n", "", s)

    s = s.split("\n---")
    s = [e for e in s if len(e) > 10]

    subjid = []

    for sub in s:
        sub = sub.split('\n')
        sub = [e.strip() for e in sub]
        sub = [e.split("#")[0].strip() for e in sub]
        sub = [e for e in sub if len(e) > 0]

        for line in sub:
            line = [e.strip() for e in line.split(":")]

            # id line
            if len(line) == 2 and line[0] == "id":
                subjid.append(line[1])
                break

    return subjid


def getSubjidFromList(filename):
    '''
    getSubjidFromList(filename)

    An internal function for reading list files. It reads the file and
    returns a list of subjects ids.

    ---
    Written by Grega Repovs and Jure Demsar.
    '''

    if not os.path.exists(filename):
        print("\n\n=====================================================\nERROR: List file does not exist [%s]", file=filename)
        raise ValueError("ERROR: List file not found: %s" % (filename))

    subjid  = []

    with open(filename) as f:
        for line in f:
            if line.strip()[:1] == "#":
                continue

            line = [e.strip() for e in line.split(":")]

            if len(line) == 2 and line[0] == "subject id":
                subjid.append(line[1])

    return subjid


def getSubjid(listString, subjectsfolder=None):
    '''
    getSubjid(listString)

    An internal function for getting a list of subject ids.

    The provided listString can be:

    * a comma, space or pipe separated list of subject id codes,
    * a path to a batch file (identified by .txt extension),
    * a path to a *.list file (identified by .list extension).

    ---
    Written by Grega Repovs and Jure Demsar.
    '''

    listString = listString.strip()

    if re.match(".*\.list$", listString):
        subjid = getSubjidFromList(listString)

    elif os.path.isfile(listString):
        subjid = getSubjidFromBatchFile(listString)

    elif re.match(".*\.txt$", listString) or '/' in listString:
        raise ValueError("ERROR: The specified subject file is not found! [%s]!" % listString)

    else:
        subjid = [e.strip() for e in re.split(' +|,|\|', listString)]

        if subjectsfolder is not None:
            nlist = []
            for s in subjid:
                nlist += glob.glob(os.path.join(subjectsfolder, s))
            subjid = [os.path.basename(e) for e in nlist]

    return subjid


def main(args=None):
    """
    mnapContainer command [parameters] --image="<path to the singularity image or docker container name>" [--script="<path to the script to run>"] [--scheduler="<scheduler settings>"] [--]
    """

    if args is None:
        args = sys.argv[1:]

    scheduler      = None
    image          = None
    command        = ""
    script         = None
    cores          = None
    subjects       = None
    subjectsfolder = None
    subjid         = None

    for arg in args:
        if "scheduler" in arg:
            k, scheduler = arg.split("=", 1)
        elif "image" in arg:
            k, image = arg.split("=", 1)
        elif "script" in arg:
            k, script = arg.split("=", 1)
        elif "cores" in arg:
            k, cores = arg.split("=", 1)
            command += '%s="%s" ' % (k, cores)
        elif "subjectsfolder" in arg:
            k, subjectsfolder = arg.split("=", 1)
            command += '%s="%s" ' % (k, subjectsfolder)
        elif "subjects" in arg:
            k, subjects = arg.split("=", 1)
            command += '%s="%s" ' % (k, subjects)
        elif "subjid" in arg:
            k, subjid = arg.split("=", 1)
        elif "=" in arg:
            k, v = arg.split('=', 1)
            command += '%s="%s" ' % (k, v)
        else:
            command += '%s ' % (arg)

    if image is None:
        if "MNAPSIMAGE" in os.environ:
            image = os.environ['MNAPSIMAGE']
        else:
            print("ERROR: No Singularity image or Docker container name specified either on command line or as a MNAPSIMAGE environment variable!")
            exit(1)

    # run in parallel if:
    # - cores is not None
    # - cores is >1
    # - schedulers is not None
    # - subjects is not None
    subjidArray = []
    if cores is not None and int(cores) > 1 and scheduler is not None and subjects is not None:
        containers = int(cores)
        # split subjects via subjid or split existing subjid
        if subjid is None:
            subjid = getSubjid(subjects, subjectsfolder=subjectsfolder)
        else:
            subjidSplit = re.split(' +|,|\|', subjid)
            subjid = [e for e in subjid if e['id'] in subjidSplit]

        # split subjids according to cores and add to array
        start = 0
        end = len(subjid)
        chunks = int(math.ceil(end / float(cores)))
        for i in range(start, end, chunks):
            start = i
            subjidChunk = subjid[start:start+chunks]
            subjidArray.append(','.join(subjidChunk))
    else:
        # do not run parallel
        containers = 1
        # add subjid filter back if exists
        if subjid is not None:
            subjidArray.append(subjid)

    for i in range(0, containers):
        scheduleCommand = command

        # add subjid to command?
        if i < len(subjidArray):
            subjid = subjidArray[i]
            scheduleCommand += 'subjid="%s" ' % (subjid)

        fid, scriptPath = tempfile.mkstemp(dir="./")
        f = os.fdopen(fid, 'w')

        print("source /opt/mnaptools/library/environment/mnap_environment.sh", file=f)
        print('export FSLDIR="/opt/fsl/fsl-5.0.9"', file=f)
        print('export PATH=${FSLDIR}:${FSLDIR}/bin:${PATH}', file=f)

        # --- run command or script
        if script:
            print("bash " + script, file=f)
        else:        
            print("bash /opt/mnaptools/connector/mnap.sh " + scheduleCommand, file=f)
        
        print("rm " + scriptPath, file=f)

        f.close()

        # singularity or docker?
        if image.endswith(".simg"):
            containerCommand = "singularity exec %s bash %s " % (image, scriptPath)
        else:
            # run docker image
            containerCommand = "docker run -d %s %s" % (image, scriptPath)
            #dockerName = "mnapDocker%d" % i
            #containerCommand = "docker run --name %s %s" % (dockerName, image)
            #containerCommand += " && docker exec -it %s bash %s" % (dockerName, scriptPath)
            #containerCommand += " && docker stop %s" % (dockerName)

        if scheduler:
            schedule(command=containerCommand, settings=scheduler)
        else:
            subprocess.Popen(containerCommand, shell=True)

if __name__ == "__main__":
    main()
